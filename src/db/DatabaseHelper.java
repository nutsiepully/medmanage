package db;

import java.sql.SQLException;

import org.vcs.medmanage.R;
import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import com.j256.ormlite.android.apptools.OrmLiteSqliteOpenHelper;
import com.j256.ormlite.dao.Dao;
import com.j256.ormlite.dao.RuntimeExceptionDao;
import com.j256.ormlite.support.ConnectionSource;
import com.j256.ormlite.table.TableUtils;

import entities.Medication;
import entities.Resident;

public class DatabaseHelper extends OrmLiteSqliteOpenHelper {
	private static final String DATABASE_NAME = "medManage.db";
	private static final int DATABASE_VERSION = 2;
	
	private Dao<Resident, Integer> residentDao = null;
	private Dao<Medication, Integer> medicationDao = null;
	private RuntimeExceptionDao<Resident, Integer> residentRuntimeDao = null;
	private RuntimeExceptionDao<Medication, Integer> medicationRuntimeDao = null;
	
	/**
	 * This is used to load the Schema from a generated config file. The config
	 * file is in res/raw, and must be generated by running DatabaseConfigUtil 
	 * each time a change is made to an Entity.
	 * @param context
	 */
	public DatabaseHelper(Context context){
		super(context, DATABASE_NAME, null ,DATABASE_VERSION, R.raw.ormlite_config);
	}
	
	@Override
	public void onCreate(SQLiteDatabase db, ConnectionSource connectionSource){
		try{
			Log.i(DatabaseHelper.class.getName(), "onCreate");
			/**
			 * LIST TABLES TO BE CREATED HERE
			 */
			TableUtils.createTable(connectionSource, Resident.class);
			TableUtils.createTable(connectionSource, Medication.class);
		}catch(Exception e){
			Log.e(DatabaseHelper.class.getName(), "Can't create database", e);
			throw new RuntimeException(e);
		}
	}
	
	@Override
	public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion, int newVersion){
		try{
			Log.i(DatabaseHelper.class.getName(), "onUpgrade");
			//Drop the old tables
			TableUtils.dropTable(connectionSource, Resident.class, true);
			TableUtils.dropTable(connectionSource, Medication.class, true);
			
			//Recreate old tables
			onCreate(db, connectionSource);
		}catch(SQLException e){
			Log.e(DatabaseHelper.class.getName(), "Can't drop databases on upgrade", e);
			throw new RuntimeException(e);
		}
	}
	
	@Override
	public void close(){
		super.close();
		//Close references to entities here
		residentRuntimeDao = null;
	}
	
	////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////
	//	DEFINE DAOs FOR ALL ENTITITES HERE
	////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////
	/**
	 * Creates a Database Access Object for the Resident class (or returns 
	 * cached value).
	 * Not called "getResidentDao" because that caused compile errors upon rename.
	 * @return
	 * @throws SQLException
	 * @throws java.sql.SQLException 
	 */
	public Dao<Resident, Integer> getDao() throws SQLException {
		if(residentDao == null){
			residentDao = getDao(Resident.class);
		}
		return residentDao;
	}
	
	/**
	 * Creates the RuntimeExceptionDao for Resident.
	 * @return
	 */
	public RuntimeExceptionDao<Resident, Integer> getResidentDataDao(){
		if(residentRuntimeDao == null){
			residentRuntimeDao = getRuntimeExceptionDao(Resident.class);
		}
		return residentRuntimeDao;
	}
	
	/**
	 * Creates a Database Access Object for the Medication class (or returns 
	 * cached value).
	 * @return
	 * @throws SQLException
	 * @throws java.sql.SQLException 
	 */
	public Dao<Medication, Integer> getMedicationDao() throws SQLException {
		if(medicationDao == null){
			medicationDao = getDao(Medication.class);
		}
		return medicationDao;
	}
	
	/**
	 * Creates the RuntimeExceptionDao for Resident.
	 * @return
	 */
	public RuntimeExceptionDao<Medication, Integer> getMedicationDataDao(){
		if(medicationRuntimeDao == null){
			medicationRuntimeDao = getRuntimeExceptionDao(Medication.class);
		}
		return medicationRuntimeDao;
	}
}


